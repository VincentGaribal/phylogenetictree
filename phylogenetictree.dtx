% \iffalse meta-comment
% !TeX program  = LuaLaTeX
% !TeX spellcheck = en-GB
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
The phylogenetictree package --- Draw phylogenetic trees
Maintained by Vincent Garibal
E-mail: vincent.garibal@gmail.com
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Phylogenetic trees are representations of evolutive relations between species.

This package works only with lualatex because it relies on lua to parse, build and export the tree.

Theres's a french translation (in fact the original version!) Inside the dtx file. To typeset it, you have to change the value of the \langue macro to anything but "english".
%</readme>
%<*ltxconfig>
\AtEndOfClass{\RequirePackage{hypdoc}}
%\AtBeginDocument{\OnlyDescription}
\AtBeginDocument{\CodelineIndex\EnableCrossrefs}
\AtEndDocument{\PrintIndex}
\AtBeginDocument{\RecordChanges}
\AtEndDocument{\PrintChanges}
%</ltxconfig>
%<*tree>
\phylogenetictree[distance=true,tree type=fold,base width=.04,base height=.28]{(Edentata:55, (((Orycteropus:12, Trichechus:43):1, (Procavia:29, (Elephas:18, Loxodonta:5):55):10):15, (((Chiroptera:27, (Tupaia:43, ((Talpa:24, (Suncus:24, Erinaceus:58):6):4, (Manis:5, ((Felis:13, Leo:7):32, ((Canis:37, Ursidae:12):4, ((Phocidae:19, Zalophus:17):7, (Procyonidae:12, Mustelidae:22):9):5):17):13):3):10):6):8, (((Lemuridae:46, (Galago:16, Nycticebus:27):10):8, (Tarsius:15, ((Cebus:10, (Atelinae:5, (Aotus:6, Callithrix:9):3):3):18, ((Hylobates:6, (Pongo:1, (Gorilla:2, (Homo:22, Pan:1):2):6):2):5, (Presbytis:1, (Cercopithecus:1, (Erythrocebus:0, ('Macaca fascicularis':2, ('Macaca mulatta':5, 'Macaca fuscata':0):1, (Theropithecus:2, Papio:4):15):2):1):8):6):9):22):10):13, ((Ochotona:7, Oryctolagus:54):4, (Caviomorpha:107, (Spermophilus:29, (Spalax:23, ((Rattus:71, Mus:19):15, (Ondatra:27, Mesocricetus:32):27):20):8):12):15):11):9):12, ((Sus:50, ((Lama:10, Camelus:24):31, (Hippopotamus:31, (((Ovis:9, Capra:8):19, ((Antilocapra:13, Giraffa:14):7, (Cervus:8, Alces:9):11):2):9, (Tragelaphinae:6, ('Bos grunniens':6, (Bison:5, 'Bos taurus':15):7):11):6):47):10):19):18, ((('Equus Asinus':6, 'Equus caballus':31):24, (Tapirus:19, Rhinocerotidae:23):11):22, ((Phocoena:4, Tursiops:17):5, (Balaenoptera:36, Eschrichtius:2):8):29):12):12):16):55);}
%</tree>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
The phylogenetictree package --- Draw phylogenetic trees
Maintained by Vincent Garibal
E-mail: vincent.garibal@gmail.com
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------
\endpreamble
\edef\luapreamble{%
--[[^^J%
This is file `\outFileName',^^J%
generated with the docstrip utility.^^J%
\ReferenceLines%
^^J%
The phylogenetictree package -Draw phylogenetic trees^^J%
Maintained by Vincent Garibal^^J%
E-mail: vincent.garibal@gmail.com^^J%
Released under the LaTeX Project Public License v1.3c or later^^J%
See http://www.latex-project.org/lppl.txt^^J%
--]]^^J^^J^^J}
\postamble
Copyright (C) 2012 by 
    Vincent Garibal <vincent.garibal@gmail.com>

It may be distributed and/or modified under the conditions of
the LaTeX Project Public License (LPPL), either version 1.3c of
this license or (at your option) any later version.  The latest
version of this license is in the file:
    http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
    Vincent Garibal.

This work consists of the file
    phylogenetictree.dtx
and the derived files 
    phylogenetictree.pdf,
    phylogenetictree.sty,
    phylogenetictree.lua,
    phylogenetictree.ins.
\endpostamble
\edef\luapostamble{^^J^^J^^J%
--[[^^J%
Copyright (C) 2012 by^^J%
Vincent Garibal <vincent.garibal@gmail.com>^^J%
^^J%
It may be distributed and/or modified under the conditions of^^J%
the LaTeX Project Public License (LPPL), either version 1.3c of^^J%
this license or (at your option) any later version.  The latest^^J%
version of this license is in the file:^^J%
http://www.latex-project.org/lppl.txt^^J%
^^J%
This work is "maintained" (as per LPPL maintenance status) by^^J%
Vincent Garibal.^^J%
^^J%
This work consists of the file^^J
phylogenetictree.dtx^^J%
and the derived files^^J
  phylogenetictree.pdf,^^J
  phylogenetictree.sty,^^J
  phylogenetictree.lua,^^J
  phylogenetictree.ins.^^J
^^J%
End of file `\outFileName'.^^J%
--]]
}
\usedir{tex/lualatex/phylogenetictree}
\generate{\file{\jobname.sty}{\from{\jobname.dtx}{package}}}
\usedir{source/lualatex/phylogenetictree}
\generate{\file{\jobname.ins}{\from{\jobname.dtx}{install}}}
\nopreamble\nopostamble
\usedir{doc/lualatex/phylogenetictree}
\generate{\file{README.txt}{\from{\jobname.dtx}{readme}}}
\nopreamble\nopostamble
\usedir{doc/lualatex/phylogenetictree}
\generate{\file{example1.tree}{\from{\jobname.dtx}{tree}}}
\nopreamble\nopostamble
\usedir{tex/lualatex/phylogenetictree}
\generate{\file{ltxdoc.cfg}{\from{\jobname.dtx}{ltxconfig}}}
\def\LuaComment{}
\let\MetaPrefix\LuaComment
\generate{%
  \usepreamble\luapreamble\usepostamble\luapostamble%
  \file{\jobname.lua}{\from{\jobname.dtx}{lua}}%
}
%</install>
%<install>\endbatchfile
%<*internal>
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass{ltxdoc}
\usepackage{fontspec}
\usepackage{xifthen}
\usepackage[backgroundcolor=white,linecolor=black,textsize=footnotesize,shadow]{todonotes}
\usepackage{epigraph}
\setlength{\epigraphwidth}{.55\linewidth}
\usepackage{\jobname}
\newcommand{\langue}{}
\renewcommand{\langue}{english}
\ifthenelse{\equal{\langue}{english}}{\usepackage[english]{babel}}{\usepackage[frenchb]{babel}}
\newcommand{\lang}[2]{\ifthenelse{\equal{\langue}{english}}{#1}{#2}}
\begin{document}
\DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%\CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%\GetFileInfo{\jobname.sty}
%\CheckSum{28}
%
%\DoNotIndex{\begin,\else,\end,\fi,\newcommand,\NeedsTeXFormat,\node,\PackageError,\ProvidesPackage,\RequirePackage,\scriptsize,\tikz,\pgfkeysvalueof}
%
%\lang{^^A
%\title{\textsf{phylogenetictree} --- Draw phylogenetic trees\thanks{This file describes version \fileversion, last modified \filedate.}}}^^A
%{\title{\textsf{phylogenetictree} --- Dessiner des arbres phylogénétiques\thanks{Ce fichier décrit la version \fileversion, modifiée le \filedate.}}}
%
%\author{Vincent Garibal\thanks{E-mail: vincent.garibal@gmail.com}}
%
%\date{\filedate}
%
%\maketitle
%
%\lang{\changes{0.1}{2013/02/25}{Separate code and user informations}}{\changes{0.1}{2013/02/25}{Séparation du code et de la documentation}}
%\lang{\changes{0.4a}{2012/07/19}{Rewrite of the module into a single dtx file}}{\changes{0.4a}{2012/07/19}{Réécriture du module sous la forme d'un seul fichier dtx}}
%\lang{\changes{0.4b}{2013/07/08}{Put ltxdoc.cfg inside dtx file}}{\changes{0.4b}{2013/07/08}{Insertion de ltxdoc.cfg dans le fichier dtx}}
%\lang{\changes{0.4c}{2013/07/08}{Change "pgfphylogenetictree" into "phylogenetictree"}}{\changes{0.4c}{2013/07/08}{Changement de nom : "phylogenetictree" à la place de pgfplylogenetictree}}
%\lang{\changes{0.4d}{2013/07/09}{Simplify key/value definitions}}{\changes{0.4d}{09/07/2013}{Simplification des définitions clés/valeurs}}
%\lang{\changes{0.4e}{2013/07/09}{Add Newick Format description}}{\changes{0.4e}{2013/07/09}{Ajout de la description du format Newick (en)}}
%
%\lang{\begin{abstract}
%The \textsf{phylogenetictree} package allows representation of phylogenetic trees. It works only with Lua\TeX.
%\end{abstract}}
%{\begin{abstract}
%Le paquet \textsf{phylogenetictree} permet de représenter des arbres phylogénétiques. Il ne fonctionne qu'avec Lua\TeX.
%\end{abstract}}
%
%\tableofcontents
%
%\lang{\section[The Newick tree format]{The Newick tree format\footnote{\url{http://evolution.genetics.washington.edu/phylip/newicktree.html}}}{}
%
%\subsection{Introduction}
%
%The Newick Standard for representing trees in computer-readable form makes use of the correspondence between trees and nested parentheses, noticed in 1857 by the famous English mathematician Arthur Cayley. If we have this rooted tree:
%
%\begin{center}
%\begin{tikzpicture}[rotate=90]
%\phylogenetictree[draw type=scope]{(B,(A,C,E),D);}
%\end{tikzpicture}
%\end{center}
%
%then in the tree file it is represented by the following sequence of printable characters:
%
%\begin{center}\verb|(B,(A,C,E),D);|\end{center}
%
%The tree ends with a semicolon. The bottommost node in this tree is an interior node, not a tip. Interior nodes are represented by a pair of matched parentheses. Between them are representations of the nodes that are immediately descended from that node, separated by commas. In the above tree, the immediate descendants are B, another interior node, and D. The other interior node is represented by a pair of parentheses, enclosing representations of its immediate descendants, A, C, and E. In our example these happen to be tips, but in general they could also be interior nodes and the result would be further nestings of parentheses, to any level.
%
%Tips are represented by their names. A name can be any string of printable characters except blanks, colons, semcolons, parentheses, and square brackets.
%
%Because you may want to include a blank in a name, it is assumed that an underscore character ("\_") stands for a blank; any of these in a name will be converted to a blank when it is read in. Any name may also be empty: a tree like
%
%\begin{center}\verb|(,(,,),);|\end{center}
%
%is allowed. Trees can be multifurcating at any level.
%
%Branch lengths can be incorporated into a tree by putting a real number, with or without decimal point, after a node and preceded by a colon. This represents the length of the branch immediately below that node. Thus the above tree might have lengths represented as:
%
%\begin{center}
%\verb|(B:6.0,(A:5.0,C:3.0,E:4.0):5.0,D:11.0);|
%\end{center}
%
%The tree starts on the first line of the file, and can continue to subsequent lines. It is best to proceed to a new line, if at all, immediately after a comma. Blanks can be inserted at any point except in the middle of a species name or a branch length.
%
%The above description is actually of a subset of the Newick Standard. For example, interior nodes can have names in that standard. These names follow the right parenthesis for that interior node, as in this example:
%
%\begin{center}
%\verb|(B:6.0,(A:5.0,C:3.0,E:4.0)Ancestor1:5.0,D:11.0);|
%\end{center}
%
%\subsection{Examples}
%
%To help you understand this tree representation, here are some trees in the above form(see section \ref{gallery}):
%
%\verb|((raccoon: 19.19959, bear: 6.80041): 0.84600, ((sea\_lion: 11.99700, seal: 12.00300): 7.52973,((monkey: 100.85930, cat:47.14069): 20.59201, weasel: 18.87953): 2.09460): 3.87382, dog:25.46154);|
%\medskip
%
%\verb|(Bovine: 0.69395, (Gibbon: 0.36079, (Orang: 0.33636, (Gorilla: 0.17147, (Chimp: 0.19268, Human: 0.11927): 0.08386): 0.06124): 0.15057): 0.54939, Mouse: 1.21460): 0.10;|
%\medskip
%
%\verb|(Bovine: 0.69395, (Hylobates: 0.36079,(Pongo: 0.33636, (G.\_Gorilla: 0.17147, (P.\_paniscus: 0.19268, H.\_sapiens: 0.11927): 0.08386): 0.06124): 0.15057): 0.54939, Rodent: 1.21460);|
%\medskip
%
%\verb|A;|
%\medskip
%
%\verb|((A,B),(C,D));|
%\medskip
%
%\verb|(Alpha,Beta,Gamma,Delta,,Epsilon,,,);|
%\medskip
%
%\subsection{(Non-)Uniqueness}
%
%The Newick Standard does not make a unique representation of a tree, for two reasons. First, the left-right order of descendants of a node affects the representation, even though it is biologically uninteresting. Thus, to a biologist
%
%\begin{center}
%\verb|(A,(B,C),D);|
%\end{center}
%is the same tree as
%\begin{center}
%\verb|(A,(C,B),D);|
%\end{center}
%which is in turn the same tree as
%\begin{center}
%\verb|(D,(C,B),A);|
%\end{center}
%and that is the same tree as
%\begin{center}
%\verb|(D,A,(C,B));|
%\end{center}
%and
%\begin{center}
%\verb|((C,B),A,D);|
%\end{center}
%
%\subsection{Rooted and unrooted trees}
%
%In addition, the standard is representing a rooted tree. For many biological purposes we may not be able to infer the position of the root. We would like to have a representation of an unrooted tree when decribing inferences in such cases. Here the convention is simply to arbitrarily root the tree and report the resulting rooted tree. Thus
%\begin{center}
%\verb|(B,(A,D),C);|
%\end{center}
%would be the same unrooted tree as
%\begin{center}
%\verb|(A,(B,C),D);|
%\end{center}
%and as
%\begin{center}
%\verb|((A,D),(C,B));|
%\end{center}
%
%\subsection{Widespread use}
%
%In spite of this limitation of nonuniqueness the readability of the resulting representation (for trees of modest size) and the ease of writing programs that read it have kept this standard in widespread use.
%
%Its competitors include the NEXUS standard for trees (part of the more general NEXUS standard for phylogeny data sets). However the NEXUS representation of trees is based on the Newick standard --- inside the NEXUS TREES Block you will find ... Newick trees.
%
%A less Newick-based standard is the PhyloXML standard, which is an XML representation using nesting the \verb|<CLADE> ... </CLADE>| tag pairs instead of parentheses.
%
%\subsection{Origin}
%
%The Newick Standard was adopted 26 June 1986 by an informal committee meeting convened by me during the Society for the Study of Evolution meetings in Durham, New Hampshire and consisting of James Archie, William H.E. Day, Wayne Maddison, Christopher Meacham, F. James Rohlf, David Swofford, and myself\footnote{Joe Felsenstein.}. (The committee was not an activity of the SSE nor endorsed by it). The reason for the name is that the second and final session of the committee met at Newick's restaurant in Dover, New Hampshire, and we enjoyed the meal of lobsters. The tree representation was a generalization of one developed by Christopher Meacham in 1984 for the tree plotting programs that he wrote for the PHYLIP package while visiting Seattle. His visit was a sabbatical leave from the University of Georgia, which thus indirectly partly funded that work.
%
%\subsection{Other descriptions of the Newick Standard}
%
%There has been no formal publication of the Newick Standard.
%
%Gary Olsen has produced a formal description of it which is available \href{http://evolution.genetics.washington.edu/phylip/newick\_doc.html}{here}.
%
%There is a Wikipedia page on the Newick Standard available \href{http://en.wikipedia.org/wiki/Newick_format}{here}.}{\section[Le format d'arbre Newick]{Le format d'arbre Newick\footnote{\url{http://evolution.genetics.washington.edu/phylip/newicktree.html}}}}
%
%\lang{\section{User interface}}{\section{Interface utilisateur}}
%
%\lang{\subsection{Main function}}{\subsection{Fonction principale}}
%
%\DescribeMacro{\phylogenetictree}
%\lang{This is the most important command for drawing phylogenetic trees. It takes one mandatory argument and several optional arguments, in the form of key/value pairs.}{Il s'agit de la fonction la plus importante pour dessiner des arbres phylogénétiques. Elle n'a qu'un seul argument obligatoire mais plusieurs arguments optionnels sous la forme de paires clé/valeur.}
%
%\lang{The mandatory argument is the tree's code. It can be directly the code or a filename in which there's the code.}{L'argument obligatoire est le code de l'arbre ; il peut s'agir directement du code ou bien du nom d'un fichier qui contient le code.}
%
%\lang{Let's start with an example:}{Commençons par un exemple :}
%\begin{figure}[ht]
%\centering
%\phylogenetictree{((a,b),(c,(d,e)),f);}
%\lang{\caption[Example of a phylogenetic tree]{\label{ExampleStraightTree}Example of phylogenetic tree. This tree was drawn with no options:  \verb|phylogenetictree\{((a,b),(c,(d,e)),f);\}|}}{\caption[Exemple d'arbre phylogénétique]{\label{ExampleStraightTree}Exemple d'arbre phylogénétique. Cet arbre a été déssiné sans arguments optionnels :  \verb|phylogenetictree\{((a,b),(c,(d,e)),f);\}|}}
%\end{figure}
%
%\lang{\subsection{Optional arguments}}{\subsection{Arguments optionnels}}
%
%\DescribeMacro{draw type}\hfill \lang{default:}{défaut :} standalone
%
%\lang{}{\verb|draw type| prend deux valeurs : \verb|standalone| qui est la valeur par défaut et qui correspond à un arbre encapsulé à l'intérieur d'un \verb|tikzpicture| ; \verb|scope| si l'on souhaite intégré l'arbre dans un \verb|tikzpicture|.}
%
%\lang{\section{Gallery\label{gallery}}}{\section{Gallerie\label{gallery}}}
%
%\phylogenetictree{((raccoon: 19.19959, bear: 6.80041): 0.84600, ((sea lion: 11.99700, seal: 12.00300): 7.52973,((monkey: 100.85930, cat:47.14069): 20.59201, weasel: 18.87953): 2.09460): 3.87382, dog:25.46154);}
%
%\phylogenetictree{(Bovine: 0.69395, (Gibbon: 0.36079, (Orang: 0.33636, (Gorilla: 0.17147, (Chimp: 0.19268, Human: 0.11927): 0.08386): 0.06124): 0.15057): 0.54939, Mouse: 1.21460): 0.10;}
%
%\phylogenetictree{(Bovine: 0.69395, (Hylobates: 0.36079,(Pongo: 0.33636, (G._Gorilla: 0.17147, (P._paniscus: 0.19268, H._sapiens: 0.11927): 0.08386): 0.06124): 0.15057): 0.54939, Rodent: 1.21460);}
%
%^^A\phylogenetictree[distance=true,base width=0.05,base height=.5]{(('raccoon':19.19959,bear:6.80041):0.84600,((sea_lion:11.99700, seal:12.00300):7.52973,((monkey:100.85930,cat:47.14069):20.59201, weasel:18.87953):2.09460):3.87382,dog:25.46154);}
%
%^^A\input{example1.tree}
%
%\StopEventually{^^A
%  \PrintIndex
%  \PrintChanges
%}
%
%\iffalse
%<*package>
%\fi
%
%\lang{\section{The Description of Macros}}{\section{Description des macros}}
%
%\epigraph{Ce que l'on conçoit bien s'énonce clairement,\\ Et les mots pour le dire arrivent aisément.}{De L'Art poétique. Chant I (1674)\\ Nicolas \textsc{Boileau}}
%
%\lang{\subsection{The \LaTeX\ code}}{\subsection{Le code \LaTeX}}
%
%\lang{\subsubsection{Definitions and packages loading}}{\subsubsection{Définitions et chargement des paquets}}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{phylogenetictree}
  [2013/07/09 0.4d Draw phylogenetic trees]
%    \end{macrocode}
%\macro{ifluatex}
%\lang{Ifluatex switch loading.}{Chargement du paquet ifluatex.}
%    \begin{macrocode}
\RequirePackage{ifluatex}
%    \end{macrocode}
%\macro{tikz} \lang{If the format is not \LaTeX, generate an error otherwise TikZ is loaded and comes with pgfkeys.}{Si \LaTeX\ n'est pas le format utilisé, une erreur est générée, sinon TikZ est chargé --- ainsi que pgfkeys.}
%    \begin{macrocode}
\ifluatex
  \RequirePackage{tikz}
\else
  \PackageError{phylogenetictree}%
  {phylogenetictree only works with LuaTeX (LaTeX format)}%
  {Switch your engine to luatex}
\fi
%    \end{macrocode}
%\lang{\subsubsection{Key/value definitions}}{\subsubsection{Définition des clés/valeurs}}
%
%\lang{}{Les valeurs données seront les valeurs par défaut. Elles sont utilisées lorsqu'on écrit un arbre sans argument par exemple.}
%    \begin{macrocode}
\pgfkeys{
  /phylogenetic tree/.cd,
  /draw type/.initial=standalone,
  /tree type/.initial=straight,
  /base width/.initial=1,
  /base height/.initial=1,
  /angle/.initial=90,
  /distance/.initial=false,
}
%    \end{macrocode}
%\begin{macro}{\phylogenetictree}
%\lang{}{La macro \verb|phylogenetictree| passe ses arguments optionnels à \verb|pgfkeys| ; s'il en manque, il utilise les valeurs par défaut. Elle appelle ensuite \verb|directlua| et passe l'ensemble des arguments dans une table lua. Enfin elle execute le fichier \verb|phylogenetictree.lua| qui contient l'ensemble des fonctions lua. Comme on travaille dans le même «chunk» lua, les valeurs passées sont toujours présentes lors de l'exécution du fichier.}
%    \begin{macrocode}
\newcommand{\phylogenetictree}[2][]{%
  \pgfkeys{#1}
  \directlua{%
    arguments = {%
      ["draw type"] = "\pgfkeysvalueof{/draw type}",
      ["tree type"] = "\pgfkeysvalueof{/tree type}",
      dx = \pgfkeysvalueof{/base width},
      dy = \pgfkeysvalueof{/base height},
      angle = \pgfkeysvalueof{/angle},
      distance = \pgfkeysvalueof{/distance},
      tree = "#2"
    }
    dofile("phylogenetictree.lua")
  }
}
%    \end{macrocode}
%\end{macro}
%\iffalse
%</package>
%<*lua>
%\fi
%
%\lang{\subsection{The Lua Code}}{\subsection{Le code Lua}}
%
%\macro{lpeg}
%\lang{The \verb|lpeg| module is required because Newick parser is written using it.}{Le module \verb|lpeg| est nécessaire puisque le parser Newick est écrit avec.}
%    \begin{macrocode}
-- lpeg module
require "lpeg"
%    \end{macrocode}
%
%\lang{\subsubsection{Auxiliary functions}}{\subsubsection{Fonctions auxiliaires}}
%
%\macro{ReadFile}
%\lang{The \verb|ReadFile| function checks if the argument of \verb|phylogenetictree| is a string or a filename. In the latter case, the file is open, and the newick tree is copied into \verb|arguments["tree"]|.}{La fonction \verb|ReadFile| teste si l'argument de \verb|phylogenetictree| (qui a été passé à lua sans changement) est une chaîne de caractères ou un nom de fichier. Dans ce cas, le fichier est lu et le code de l'arbre est copié dans  \verb|arguments["tree"]|.}
%    \begin{macrocode}
-- ReadFile function
-- Check if the tree is a string or a file
function ReadFile (newicktree)
  local tree = ""
  local file, errorMsg = io.open(newicktree, "r")
  if not file then
    if type(newicktree) ~= "string" then
      tex.error(errorMsg)
    end
  else
    for line in io.lines(newicktree) do
      tree = tree..line
    end
    arguments["tree"] = tree
  end
end
%    \end{macrocode}
%\begin{macro}{FindAllLeaves}
%\lang{The \verb|FindAllLeaves| function finds all leaves of a tree associated with a particular node. It's a recursive function. It takes three arguments : }{La fonction \verb|FindAllLeaves| trouve puis copie toutes les feuilles associées à un nœud parent particulier. C'est une fonction récursive. Elle prend trois arguments : \verb|tree|, la table contenant le code de l'arbre parsé ; \verb|leaves|, une table dans laquelle sera écrit l'ensemble des feuilles ; \verb|parent|, un nœud parent.}
%    \begin{macrocode}
-- FindAllLeaves function (recursive)
-- Finds all leaves of a tree associated with a particular node
function FindAllLeaves (tree, leaves, parent)
  if type(tree[parent]["childs"]) == "table" then
    for _,v in pairs (tree[parent]["childs"]) do
      FindAllLeaves (tree, leaves, v)
    end
  elseif tree[parent]["childs"] == nil then
    table.insert(leaves,parent)
  end
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{GetNum}
%\lang{The \verb|Getnum| function gives the total number of entries in an indexed table.}{La fonction \verb|Getnum| donne le nombre total d'entrées dans une table indexée.}
%    \begin{macrocode}
-- GetNum function
-- Give the total number of entries in an indexed table
function GetNum (table)
  local count = 0
  for k in pairs(table) do
    count = count + 1
  end
  return count
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{Gsub}
%\lang{The \verb|Gsub| function (\href{http://www.inf.puc-rio.br/~roberto/lpeg/\#ex}{lpeg documentation}) is an implementation of the \verb|string.gsub| function (plain lua) with \verb|lpeg|.}{La fonction \verb|Gsub| (\href{http://www.inf.puc-rio.br/~roberto/lpeg/\#ex}{documentation de lpeg}) implémente la fonction \verb|string.gsub| (plain lua) avec \verb|lpeg|.}
%    \begin{macrocode}
-- Gsub function
-- Implementation of the string.gsub function (plain lua) with lpeg
function Gsub (string, pattern, replacement)
  pattern = lpeg.P(pattern)
  pattern = lpeg.Cs((pattern / replacement + 1)^0)
  return lpeg.match(pattern, string)
end
%    \end{macrocode}
%\end{macro}
%\subsubsection{Newick Parser}
%\begin{macro}{NewickParser}
%\todo{find a better algorithm}\lang{The \verb|NewickParser| function transforms inline Newick notation into a table.}{La fonction \verb|NewickParser| transforme la notation Newick en table.}
%    \begin{macrocode}
-- NewickParser function
-- Transforms inline Newick notation into a table
function NewickParser (newicktree)
%    \end{macrocode}
%\lang{\paragraph{Variables declarations}}{\paragraph{Déclaration des variables}}
%    \begin{macrocode}
  -- variable declarations
  local node = {}
  local newicktable = {}
  local node_number = 1
  local current_node = 1
  local parent_node = 0
  local counter = 1
%    \end{macrocode}
%\lang{Pattern definitions: declaration of all the symbols used by Newick format.}{\paragraph{Déclaration des motifs de recherche} Pour chacun des symboles de la grammaire Newick, on déclare une variable.}
%    \begin{macrocode}
  -- Newick grammar
  local space = lpeg.P(" ")
  local digit = lpeg.P(lpeg.R("09"))
  local number = lpeg.P(digit + ".")

  local colon                = lpeg.P(":")
  local semicolon            = lpeg.P(";")
  local comma                = lpeg.P(",")
  local singlequote          = lpeg.P("'")
  local doublequote          = lpeg.P('"')
  local underscore           = lpeg.P("_")
  local leftparenthesis      = lpeg.P("(")
  local rightparenthesis     = lpeg.P(")")
  local leftsquarebracket    = lpeg.P("[")
  local rightsquarebracket   = lpeg.P("]")

  local NewickPunctuation = lpeg.P(leftparenthesis
    + rightparenthesis + colon + semicolon + comma)	
  local comments = lpeg.P(leftsquarebracket + rightsquarebracket)
%    \end{macrocode}
%\lang{The following pattern is more complex. It is based on an example of the \href{http://www.inf.puc-rio.br/~roberto/lpeg/\#ex}{\verb|lpeg| documentation (Balanced parentheses)}}{\todo{translate in english}Le motif suivant est plus complexe. Le code se base un des exemples donnés dans la  \href{http://www.inf.puc-rio.br/~roberto/lpeg/\#ex}{documentation de \verb|lpeg| (Balanced parentheses)}. Il s'agit de trouver une chaîne qui est \emph{exactement} entre deux crochets (\emph{balanced brackets}). Une chaîne entre crochets commence donc par 
%\begin{enumerate}
%\item un crochet gauche,
%\item suivi de 0 ou plus répétitions de n'importe quoi sauf 1) des crochets (\verb|(1 - lpeg.S("[]"))|) ou 2) une chaine entre crochets (\verb|lpeg.V(1)|)
%\item et terminé par un crochet droit.
%\end{enumerate}}
%    \begin{macrocode}
  local balancedcommentpattern = lpeg.P{
    leftsquarebracket * 
    ((1 - lpeg.S("[]")) + lpeg.V(1))^0
    * rightsquarebracket
  }
%    \end{macrocode}
%\lang{}{Le motif pour les guillemets simples est construit de la même façon que le motif précédent pour les crochets.}
%    \begin{macrocode}
  local balancedsinglequotepattern = lpeg.P{
    singlequote * 
    ((1 - lpeg.S("'")) + lpeg.V(1))^0
    * singlequote
  }
%    \end{macrocode}
%\lang{}{Le motif pour les guillemets doubles est construit de la même façon que le motif précédent pour les crochets.}
%    \begin{macrocode}
  local balanceddoublequotepattern = lpeg.P{
    doublequote * 
    ((1 - lpeg.S('"')) + lpeg.V(1))^0
    * doublequote
  }
%    \end{macrocode}
%\lang{\paragraph{Convert inline tree into a table}}{\paragraph{Conversion de l'arbre en table}\todo{Is it possible to do this with only 1 table?}}
%
%\lang{While the counter's value is smaller than the string's length, the loop continues.}{Tant que la valeur du compteur est inférieure à la longueur totale du code de l'arbre, la boucle continue.}
%    \begin{macrocode}
  -- copy Newick's characters into the table
  while counter <= string.len(newicktree) do
%    \end{macrocode}
%\lang{If the character is one of the Newick's grammar, it is moved into the table and the counter is incremented by one.}{Si le caractère correspond à un motif de la grammaire, on copie ce motif dans la table temporaire et on incrémente le compteur de 1.}
%    \begin{macrocode}
    if lpeg.match(NewickPunctuation,newicktree,counter) then
      table.insert(
        newicktable,lpeg.match(
          lpeg.C(NewickPunctuation),newicktree,counter
        )
      )
      counter = counter + 1
%    \end{macrocode}
%\lang{If the character is a "[", it means there's a comment. It removes everything between "[" and "]" and the characters themselves.}{Si le caractère est un "[" cela marque le début d'un commentaire.}
%    \begin{macrocode}
    -- matches comments
    elseif lpeg.match(balancedcommentpattern,newicktree,counter) then
      counter = lpeg.match(balancedcommentpattern,newicktree,counter+1)
%    \end{macrocode}
%\todo{translate in french}If the character is a ' or a ", it means there's a label. It matches everything between \texttt{'} and \texttt{'}.
%    \begin{macrocode}
    -- matches labels
    elseif lpeg.match(balancedsinglequotepattern,newicktree,counter) then
      table.insert(newicktable,lpeg.match(lpeg.C(balancedsinglequotepattern),
        newicktree,counter))
      counter = lpeg.match(balancedsinglequotepattern,newicktree,counter+1)

%    \end{macrocode}
%\todo{translate in french}Remove spaces between Newick grammar.
%    \begin{macrocode}
    -- Remove spaces between Newick grammar
    elseif lpeg.match(space,newicktree,counter) then
      counter = counter + 1

%    \end{macrocode}
%\todo{translate in french}Remove single quotes et replace underscore with space.
%    \begin{macrocode}
    -- Remove single quotes et replace underscore with space
    else
      local strpatt = lpeg.P((1-(NewickPunctuation + comments))^0)
      local str = lpeg.match(lpeg.C(strpatt),newicktree,counter)
      str = Gsub(str,singlequote,"")
      str = Gsub(str,underscore," ")
      table.insert(newicktable,str)
      strpatt = lpeg.P((1-NewickPunctuation)^0)
      counter = counter + (lpeg.match(strpatt,newicktree,counter)-counter)
    end
  end -- end of while loop

%    \end{macrocode}
%\paragraph{\todo{translate in french}Construction of the final table}
%The node 1 (root) is its own parent.
%    \begin{macrocode}
  -- The node 1 (root) is its own parent
  node[1] = {
    type = "node",
    label = "",
    distance = 0,
    parent = 1,
    childs = {},
    x = 0,
    y = 0
  }

%    \end{macrocode}
%\todo{translate in french}Loop each value in the temporary table.
%    \begin{macrocode}
  -- Loop each value in the temporary table
  for k,v in pairs(newicktable) do

%    \end{macrocode}
%\todo{translate in french}Left parenthesis: create a new child node.
%    \begin{macrocode}
    -- Left parenthesis : create a new child node
    if lpeg.match(leftparenthesis,v) then
      parent_node = node_number
      node_number = node_number + 1
      current_node = node_number
      table.insert((node[parent_node]["childs"]), current_node)
      node[current_node] = {
        type = "node",
        label = "",
        distance = 1,
        parent = parent_node,
        childs = {},
        x = 0,
        y = 0
      }
      if lpeg.match(comma,newicktable[k+1]) then
        node[current_node]["type"] = "leaf"
      end

%    \end{macrocode}
%\todo{translate in french}Comma: come back to parent and create new child node.
%    \begin{macrocode}
    -- Comma: come back to parent and create new child node
    elseif lpeg.match(comma,v) then
      parent_node = node[current_node]["parent"]
      node_number = node_number + 1
      current_node = node_number
      table.insert(node[parent_node]["childs"], current_node)
      node[current_node] = {
        type = "node",
        label = "",
        distance = 1,
        parent = parent_node,
        childs = {},
        x = 0,
        y = 0
      }
      if lpeg.match(rightparenthesis,newicktable[k+1]) then
        node[current_node]["type"] = "leaf"
      end

%    \end{macrocode}
%\todo{translate in french}Right parenthesis: come back to parent node.
%    \begin{macrocode}
    -- Right parenthesis: come back to parent node
    elseif lpeg.match(rightparenthesis,v) then
      current_node = parent_node
      parent_node = node[parent_node]["parent"]

%    \end{macrocode}
%\todo{translate in french}Semicolon: end of tree and so end of loop!
%    \begin{macrocode}
    elseif lpeg.match(semicolon,v) then
      break
%    \end{macrocode}
%\todo{translate in french}Colon: do nothing in the loop (it means there's a distance, but it's not important for the moment)
%    \begin{macrocode}
    elseif lpeg.match(colon,v) then
%    \end{macrocode}
%\todo{translate in french}A number is a distance. We put this number in the node table.
%    \begin{macrocode}
    elseif lpeg.match(number,v) then
      node[current_node]["distance"] = v
%    \end{macrocode}
%\todo{translate in french}Internal node label. If the current value is not a Newick sign but the previous is a right parenthesis, then it's the name of an internal node.
%    \begin{macrocode}
    elseif lpeg.match(rightparenthesis,newicktable[k-1]) then
      node[current_node]["label"] = v
%    \end{macrocode}
%\todo{translate in french}Anything else is the label of an external node (a leaf).
%    \begin{macrocode}
    else
      node[current_node]["type"] = "leaf"
      node[current_node]["label"] = v
      node[current_node]["childs"] = nil
    end

%    \end{macrocode}
%\todo{translate in french}End of loop, end of function, return the node table.
%    \begin{macrocode}
  end
  return node -- return thee node table
end
%    \end{macrocode}
%\end{macro}
%\lang{\subsubsection{Composing functions}}{\subsubsection{Fonction de composition}}
%
%\begin{macro}{Table2FoldTree}
%Compute node coordinates with fold angles
%    \begin{macrocode}
-- Table2FoldTree function
-- Compute node coordinates with fold angles
function Table2FoldTree (node)
  local parent = {}
  local currentparent = 0
  local child = {}
  local coordinates = {x={},y=1}
%    \end{macrocode}
%    \begin{macrocode}
  for k in ipairs(node) do
    if node[k]["type"] == "leaf" then
      table.insert(parent,node[k]["parent"])
      node[k]["y"] = coordinates["y"] - arguments["dy"]
      coordinates["y"] = node[k]["y"]
    end
  end
%    \end{macrocode}
%\lang{Loop while parent is superior to 1}{}
%    \begin{macrocode}
  -- boucle tant que parent est supérieur à 1
  while GetNum(parent) > 1 do 
    -- on réinitialise les tables temporaires
    coordinates = {x={},y={}}
    child = {}
    -- on prend le parent avec le numéro le plus élevé (pour avoir la racine en dernier)
    currentparent =math.max(unpack(parent))
    -- on prend tous les enfants du parent courant --> child
    for k,v in pairs(node[currentparent]["childs"]) do
      table.insert(child,v)
    end
    -- on récupère les coordonnées des enfants
    for k,v in pairs(child) do
      table.insert(coordinates["x"],node[v]["x"])
      table.insert(coordinates["y"],node[v]["y"])
    end

		-- on calcule les coordonnées du parent
		node[currentparent]["x"] = (math.min(unpack(coordinates["x"])))-arguments["dx"]
		node[currentparent]["y"] =
              (math.max(unpack(coordinates["y"])))
             -((math.abs((math.max(unpack(coordinates["y"])))
             -(math.min(unpack(coordinates["y"])))))/2)

		-- on enlève les noeuds avec le parent en cours
		local counter = 1
		while parent[counter] ~= nil do
			if parent[counter] == currentparent then
				table.remove(parent,counter)
			else
				counter = counter + 1
			end
		end
		
		-- on ajoute le parent du noeud parent
		table.insert(parent,node[currentparent]["parent"])
	end

	-- on positionne la noeud root à 0,0
	local xroot = node[1]["x"]
	local yroot = node[1]["y"]
	for k in pairs(node) do
		node[k]["x"] = node[k]["x"]-xroot
		node[k]["y"] = node[k]["y"]-yroot
	end
	return node
end
%    \end{macrocode}
%\end{macro}
%     \begin{macrocode}
-- Table2FoldTreeDistance function
-- calcule les coordonnées des noeuds avec des 
-- branches à angle droit en respectant les distances
function Table2FoldTreeDistance (node)
	Table2FoldTree(node)
	for k in ipairs(node) do
		-- on décale les noeuds en x pour avoir les bonnes coordonnées
		node[k]["x"] = node[node[k]["parent"]]["x"] + arguments["dx"]*node[k]["distance"]
	end
	return node
end


----------------------------------------------------------------------
-- calcule les coordonées des noeuds avec des branches en ligne droite
----------------------------------------------------------------------
function Table2StraightTree (node)

  local parent = {}
  local currentparent = 0
  local child = {}
  local coordinates = {x={},y=1}

  -- place les feuilles de l'arbre
  for k in ipairs(node) do
    if node[k]["type"] == "leaf" then
      table.insert(parent,node[k]["parent"])
      node[k]["y"] = coordinates["y"] - arguments["dy"] -- on modifie y du noeud
      coordinates["y"] = node[k]["y"]
    end
  end

  -- boucle tant que parent est supérieur à 1
  while GetNum(parent) > 1 do

    -- on réinitialise les tables temporaires
    coordinates = {x={},y={}}
    child = {}

    -- on prend le parent avec le numéro le plus élevé (pour avoir la racine en dernier)
    currentparent = math.max(unpack(parent))

    -- on cherche toutes les feuilles du parent recherché et on les ajoute dans childs
    FindAllLeaves(node,child,currentparent)

    -- on prend tous les enfants directs du parent courant --> child
    for k,v in pairs(node[currentparent]["childs"]) do
      table.insert(child,v)
    end

    -- on récupère les coordonnées des enfants
    for k,v in pairs(child) do
      table.insert(coordinates["x"],node[v]["x"])
      table.insert(coordinates["y"],node[v]["y"])
    end

    local xmin = math.min(unpack(coordinates["x"]))
    local xmax = math.max(unpack(coordinates["x"]))
    local ymin = math.min(unpack(coordinates["y"]))
    local ymax = math.max(unpack(coordinates["y"]))
%    \end{macrocode}
%\lang{}{Calcul de $dx$. 
%$$\|y_{max}-y_{min}\|\times 0.5$$}
%    \begin{macrocode}
    local dx = (
      ((math.abs(ymax-ymin))*.5)
      *
      (math.sqrt((1+math.cos(math.rad(arguments["angle"])))
       /
       (1-math.cos(math.rad(arguments["angle"])))))
     )

    -- on calcule les coordonnées du parent
    node[currentparent]["x"] = xmax-dx
    node[currentparent]["y"] = ymax-((math.abs(ymax-ymin))/2)

    -- on enlève les noeuds avec le parent en cours
    local counter = 1
    while parent[counter] ~= nil do
      if parent[counter] == currentparent then
        table.remove(parent,counter)
      else
        counter = counter + 1
      end
    end
		
    -- on ajoute le parent du noeud parent
    table.insert(parent,node[currentparent]["parent"])
  end

  -- on positionne la noeud root à 0,0
  local xroot = node[1]["x"]
  local yroot = node[1]["y"]
  for k in pairs(node) do
    node[k]["x"] = node[k]["x"]-xroot
    node[k]["y"] = node[k]["y"]-yroot
  end
  return node
end

%    \end{macrocode}
%\lang{\subsubsection{Drawing functions}}{\subsubsection{Fonctions de dessin}}
%
%\begin{macro}{Labels}
%    \begin{macrocode}
-- print labels
function Labels (node)
  for k in ipairs (node) do
    tex.print(
      [[\node [anchor=west] at (]]
      ..node[k]["x"]
      ..[[cm,]]
      ..node[k]["y"]
      ..[[cm) (]]
      ..k
      ..[[) {]]
      ..node[k]["label"]
      ..[[};]]
    )
  end
end
%    \end{macrocode}
%\end{macro}
%    \begin{macrocode}
-----------------------------
-- print node numbers (debug)
-----------------------------
function NodeNumber (node)
  for k in ipairs (node) do
    tex.print([[\node [draw,anchor=south east,circle] at (]]..node[k]["x"]..[[cm,]]..node[k]["y"]..[[cm) (]]..k..[[) {\scriptsize{]]..k..[[}};]])
  end
end

-- Relie tous les noeuds en formant un angle droit
function FoldTree (node)
	for k in ipairs (node) do
		tex.print([[\draw (]]..node[node[k]["parent"]]["x"]..[[cm,]]..node[node[k]["parent"]]["y"]..[[cm) |- (]]..node[k]["x"]..[[cm,]]..node[k]["y"]..[[cm);]])
	end
end

function StraightTree (node)
	for k in ipairs (node) do
		tex.print([[\draw (]]..node[node[k]["parent"]]["x"]..[[cm,]]..node[node[k]["parent"]]["y"]..[[cm) -- (]]..node[k]["x"]..[[cm,]]..node[k]["y"]..[[cm);]])
	end
end

-- encapsule le code dans un tikzpicture
function TikzDraw (tree)

	local starttikzenv
	local endtikzenv
	
	-- plain or latex
	if arguments["draw type"] == "standalone" then
		starttikzenv = [[\begin{tikzpicture}]]
		endtikzenv = [[\end{tikzpicture}]]
	elseif arguments["draw type"] == "scope" then
		starttikzenv = [[\begin{scope}]]
		endtikzenv = [[\end{scope}]]
	end

	tex.print(starttikzenv)
	if arguments["tree type"] == "straight" then
		if arguments["distance"] == false then
			StraightTree(Table2StraightTree(tree))
			Labels(tree)
		elseif arguments["distance"] == true then
			StraightTree(Table2StraightTreeDistance(tree))
			Labels(tree)
		end
	elseif arguments["tree type"] == "fold" then
		if arguments["distance"] == false then
			FoldTree(Table2FoldTree(tree))
			Labels(tree)
		elseif arguments["distance"] == true then
			FoldTree(Table2FoldTreeDistance(tree))
			Labels(tree)
		end
	end
	tex.print(endtikzenv)
end

ReadFile(arguments["tree"])
TikzDraw(NewickParser(arguments["tree"]))
%    \end{macrocode}
%\iffalse
%</lua>
%\fi
%\Finale