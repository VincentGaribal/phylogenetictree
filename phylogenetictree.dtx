% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
The phylogenetictree package --- Draw phylogenetic trees
Maintained by Vincent Garibal
E-mail: vincent.garibal@gmail.com
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Phylogenetic trees are representations of evolutive relations between species.

This package works only with lualatex because it relies on lua to parse, build
and export the tree.
%</readme>
%<*tree>
(Edentata:55, (((Orycteropus:12, Trichechus:43):1, (Procavia:29, (Elephas:18,
Loxodonta:5):55):10):15, (((Chiroptera:27, (Tupaia:43, ((Talpa:24, (Suncus:24,
Erinaceus:58):6):4, (Manis:5, ((Felis:13, Leo:7):32, ((Canis:37, Ursidae:12):4,
((Phocidae:19, Zalophus:17):7, (Procyonidae:12,
Mustelidae:22):9):5):17):13):3):10):6):8, (((Lemuridae:46, (Galago:16,
Nycticebus:27):10):8, (Tarsius:15, ((Cebus:10, (Atelinae:5, (Aotus:6,
Callithrix:9):3):3):18, ((Hylobates:6, (Pongo:1, (Gorilla:2, (Homo:22,
Pan:1):2):6):2):5, (Presbytis:1, (Cercopithecus:1, (Erythrocebus:0, ('Macaca
fascicularis':2, ('Macaca mulatta':5, 'Macaca fuscata':0):1, (Theropithecus:2,
Papio:4):15):2):1):8):6):9):22):10):13, ((Ochotona:7, Oryctolagus:54):4,
(Caviomorpha:107, (Spermophilus:29, (Spalax:23, ((Rattus:71, Mus:19):15,
(Ondatra:27, Mesocricetus:32):27):20):8):12):15):11):9):12, ((Sus:50, ((Lama:10,
Camelus:24):31, (Hippopotamus:31, (((Ovis:9, Capra:8):19, ((Antilocapra:13,
Giraffa:14):7, (Cervus:8, Alces:9):11):2):9, (Tragelaphinae:6, ('Bos
grunniens':6, (Bison:5, 'Bos taurus':15):7):11):6):47):10):19):18, ((('Equus
Asinus':6, 'Equus caballus':31):24, (Tapirus:19, Rhinocerotidae:23):11):22,
((Phocoena:4, Tursiops:17):5, (Balaenoptera:36,
Eschrichtius:2):8):29):12):12):16):55);
%</tree>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
The phylogenetictree package --- Draw phylogenetic trees
Maintained by Vincent Garibal
E-mail: vincent.garibal@gmail.com
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------
\endpreamble
\edef\luapreamble{%
--[[^^J%
This is file `\outFileName',^^J%
generated with the docstrip utility.^^J%
\ReferenceLines%
^^J%
The phylogenetictree package -Draw phylogenetic trees^^J%
Maintained by Vincent Garibal^^J%
E-mail: vincent.garibal@gmail.com^^J%
Released under the LaTeX Project Public License v1.3c or later^^J%
See http://www.latex-project.org/lppl.txt^^J%
--]]^^J^^J^^J}
\postamble
Copyright (C) 2012 2013 by 
    Vincent Garibal <vincent.garibal@gmail.com>

It may be distributed and/or modified under the conditions of
the LaTeX Project Public License (LPPL), either version 1.3c of
this license or (at your option) any later version.  The latest
version of this license is in the file:
    http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
    Vincent Garibal.

This work consists of the file
    phylogenetictree.dtx
and the derived files 
    phylogenetictree.pdf,
    phylogenetictree.sty,
    phylogenetictree.lua,
    phylogenetictree.ins.
\endpostamble
\edef\luapostamble{^^J^^J^^J%
--[[^^J%
Copyright (C) 2012 2013 by^^J%
Vincent Garibal <vincent.garibal@gmail.com>^^J%
^^J%
It may be distributed and/or modified under the conditions of^^J%
the LaTeX Project Public License (LPPL), either version 1.3c of^^J%
this license or (at your option) any later version.  The latest^^J%
version of this license is in the file:^^J%
http://www.latex-project.org/lppl.txt^^J%
^^J%
This work is "maintained" (as per LPPL maintenance status) by^^J%
Vincent Garibal.^^J%
^^J%
This work consists of the file^^J
phylogenetictree.dtx^^J%
and the derived files^^J
  phylogenetictree.pdf,^^J
  phylogenetictree.sty,^^J
  phylogenetictree.lua,^^J
  phylogenetictree.ins.^^J
^^J%
End of file `\outFileName'.^^J%
--]]
}
\usedir{tex/lualatex/phylogenetictree}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
\usedir{source/lualatex/phylogenetictree}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/lualatex/phylogenetictree}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\generate{
  \file{example1.tree}{\from{\jobname.dtx}{tree}}
}
\nopreamble\nopostamble
\usedir{tex/lualatex/phylogenetictree}
\def\LuaComment{}
\let\MetaPrefix\LuaComment
\generate{
  \usepreamble\luapreamble\usepostamble\luapostamble%
  \file{\jobname.lua}{\from{\jobname.dtx}{lua}}%
}
%</install>
%<install>\endbatchfile
%<*internal>
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass{l3doc}
\usepackage{fontspec}
\usepackage{\jobname}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \DoNotIndex{
%   \begin,
%   \end,
%   \fi,
%   \iffalse 
% }
%
% \GetFileInfo{\jobname.sty}
%
% \title{\textsf{phylogenetictree} --- Draw phylogenetic trees^^A
% \thanks{This file describes version \fileversion, last modified \filedate.}}
%
% \author{Vincent Garibal\thanks{E-mail: \texttt{vincent.garibal@gmail.com}}}
%
% \date{Released \filedate}
%
% \maketitle
%
% \changes{0.1}{2013/02/25}{Separate code and user informations}
% \changes{0.4a}{2012/07/19}{Rewrite of the module into a single dtx file}
% \changes{0.4b}{2013/07/08}{Put ltxdoc.cfg inside dtx file}
% \changes{0.4c}{2013/07/08}{Change "pgfphylogenetictree" into
%   "phylogenetictree"}
% \changes{0.4d}{2013/07/09}{Simplify key/value definitions}
% \changes{0.4e}{2013/07/09}{Add Newick Format description}
% \changes{0.4f}{2013/10/26}{Replace \texttt{pgfkeys} by \texttt{l3keys}}
% \changes{0.5}{2013/10/29}{Apply \LaTeX3 syntax}
%
% \begin{abstract}
% The \textsf{phylogenetictree} package allows representation of phylogenetic
% trees. It works only with Lua\TeX (for the moment).
% \end{abstract}
%
% \tableofcontents
%
% \newpage
%
% \begin{documentation}
%
% \section[The Newick tree format]{The Newick tree format\footnote{
%   \url{http://evolution.genetics.washington.edu/phylip/newicktree.html}}}
%
% \subsection{Introduction}
%
% The Newick Standard for representing trees in computer-readable form makes use
% of the correspondence between trees and nested parentheses, noticed in 1857 by
% the famous English mathematician Arthur Cayley. If we have this rooted tree:
%
% \begin{center}
% \begin{tikzpicture}[rotate=90]
% \phylogenetictree[draw_type=scope]{(B,(A,C,E),D);}
% \end{tikzpicture}
% \end{center}
% then in the tree file it is represented by the following sequence of printable
% characters:
% \begin{center}
% |(B,(A,C,E),D);|
% \end{center}
%
% The tree ends with a semicolon. The bottommost node in this tree is an interior
% node, not a tip. Interior nodes are represented by a pair of matched
% parentheses. Between them are representations of the nodes that are immediately
% descended from that node, separated by commas. In the above tree, the immediate
% descendants are B, another interior node, and D. The other interior node is
% represented by a pair of parentheses, enclosing representations of its immediate
% descendants, A, C, and E. In our example these happen to be tips, but in general
% they could also be interior nodes and the result would be further nestings of
% parentheses, to any level.
%
% Tips are represented by their names. A name can be any string of printable
% characters except blanks, colons, semcolons, parentheses, and square brackets.
%
% Because you may want to include a blank in a name, it is assumed that an
% underscore character ("_") stands for a blank; any of these in a name will be
% converted to a blank when it is read in. Any name may also be empty: a tree like
%
% \begin{center}
% |(,(,,),);|
% \end{center}
%
% is allowed. Trees can be multifurcating at any level.
%
% Branch lengths can be incorporated into a tree by putting a real number, with
% or without decimal point, after a node and preceded by a colon. This represents
% the length of the branch immediately below that node. Thus the above tree might
% have lengths represented as:
%
% \begin{center}
% |(B:6.0,(A:5.0,C:3.0,E:4.0):5.0,D:11.0);|
% \end{center}
%
% The tree starts on the first line of the file, and can continue to subsequent
% lines. It is best to proceed to a new line, if at all, immediately after a
% comma. Blanks can be inserted at any point except in the middle of a species
% name or a branch length.
% 
% The above description is actually of a subset of the Newick Standard. For
% example, interior nodes can have names in that standard. These names follow the
% right parenthesis for that interior node, as in this example:
%
% \begin{center}
% |(B:6.0,(A:5.0,C:3.0,E:4.0)Ancestor1:5.0,D:11.0);|
% \end{center}
%
% \subsection{Examples}
%
% To help you understand this tree representation, here are some trees in the
% above form(see section \ref{gallery}):
%
% \texttt{((raccoon: 19.19959, bear: 6.80041): 0.84600, ((sea\_lion: 11.99700,
% seal: 12.00300): 7.52973,((monkey: 100.85930, cat:47.14069): 20.59201, weasel:
% 18.87953): 2.09460): 3.87382, dog:25.46154);}
% \medskip
%
% \texttt{(Bovine: 0.69395, (Gibbon: 0.36079, (Orang: 0.33636, (Gorilla: 0.17147,
% (Chimp: 0.19268, Human: 0.11927): 0.08386): 0.06124): 0.15057): 0.54939, Mouse:
% 1.21460): 0.10;}
% \medskip
%
% \texttt{(Bovine: 0.69395, (Hylobates: 0.36079,(Pongo: 0.33636, (G.\_Gorilla:
% 0.17147, (P.\_paniscus: 0.19268, H.\_sapiens: 0.11927): 0.08386): 0.06124):
% 0.15057): 0.54939, Rodent: 1.21460);}
% \medskip
%
% |A;|
% \medskip
%
% |((A,B),(C,D));|
% \medskip
%
% |(Alpha,Beta,Gamma,Delta,,Epsilon,,,);|
% \medskip
%
% \subsection{(Non-)Uniqueness}
%
% The Newick Standard does not make a unique representation of a tree, for two
% reasons. First, the left-right order of descendants of a node affects the
% representation, even though it is biologically uninteresting. Thus, to a
% biologist
%
% \begin{center}
% |(A,(B,C),D);|
% \end{center}
% is the same tree as
% \begin{center}
% |(A,(C,B),D);|
% \end{center}
% which is in turn the same tree as
% \begin{center}
% |(D,(C,B),A);|
% \end{center}
% and that is the same tree as
% \begin{center}
% |(D,A,(C,B));|
% \end{center}
% and
% \begin{center}
% |((C,B),A,D);|
% \end{center}
%
% \subsection{Rooted and unrooted trees}
%
% In addition, the standard is representing a rooted tree. For many biological
% purposes we may not be able to infer the position of the root. We would like to
% have a representation of an unrooted tree when decribing inferences in such
% cases. Here the convention is simply to arbitrarily root the tree and report the
% resulting rooted tree. Thus
% \begin{center}
% |(B,(A,D),C);|
% \end{center}
% would be the same unrooted tree as
% \begin{center}
% |(A,(B,C),D);|
% \end{center}
% and as
% \begin{center}
% |((A,D),(C,B));|
% \end{center}
%
% \subsection{Widespread use}
%
% In spite of this limitation of nonuniqueness the readability of the resulting
% representation (for trees of modest size) and the ease of writing programs that
% read it have kept this standard in widespread use.
%
% Its competitors include the NEXUS standard for trees (part of the more general
% NEXUS standard for phylogeny data sets). However the NEXUS representation of
% trees is based on the Newick standard --- inside the NEXUS TREES Block you will
% find ... Newick trees.
%
% A less Newick-based standard is the PhyloXML standard, which is an XML
% representation using nesting the \verb|<CLADE> ... </CLADE>| tag pairs instead
% of parentheses.
%
% \subsection{Origin}
%
% The Newick Standard was adopted 26 June 1986 by an informal committee meeting
% convened by me during the Society for the Study of Evolution meetings in Durham,
% New Hampshire and consisting of James Archie, William H.E. Day, Wayne Maddison,
% Christopher Meacham, F. James Rohlf, David Swofford, and myself\footnote{Joe
% Felsenstein.}. (The committee was not an activity of the SSE nor endorsed by
% it). The reason for the name is that the second and final session of the
% committee met at Newick's restaurant in Dover, New Hampshire, and we enjoyed the
% meal of lobsters. The tree representation was a generalization of one developed
% by Christopher Meacham in 1984 for the tree plotting programs that he wrote for
% the PHYLIP package while visiting Seattle. His visit was a sabbatical leave from
% the University of Georgia, which thus indirectly partly funded that work.
%
% \subsection{Other descriptions of the Newick Standard}
%
% There has been no formal publication of the Newick Standard.
%
% Gary Olsen has produced a formal description of it which is available
% \href{http://evolution.genetics.washington.edu/phylip/newick\_doc.html}{here}.
%
% There is a Wikipedia page on the Newick Standard available
% \href{http://en.wikipedia.org/wiki/Newick_format}{here}.
%
% \section{User interface}
%
% \begin{function}{ \phylogenetictree }
%   \begin{syntax}
%     "\phylogenetictree:d[]m" <key=value> \marg{filename or tree}
%   \end{syntax}
%   This is the most important command for drawing phylogenetic trees. It takes one
%   mandatory argument and several optional arguments, in the form of key/value
%   pairs.
%
%   The mandatory argument is the tree's code. It can be directly the code or a
%   filename in which there's the code.
% \end{function}
%
% Let's start with an example:
% \begin{figure}[ht]
% \centering
% \phylogenetictree[]{((a,b),(c,(d,e)),f);}
% \caption[Example of a phylogenetic tree]{\label{ExampleStraightTree}Example of
%   phylogenetic tree. This tree was drawn with no options:
% |phylogenetictree\{((a,b),(c,(d,e)),f);\}|}
% \end{figure}
%
% \subsection{Optional arguments}
%
% \DescribeMacro{draw type}\hfill default: standalone
%
% |draw type| takes two values : |standalone| which is the default value.
%
% \section{Gallery\label{gallery}}
%
%^^A\phylogenetictree{((raccoon: 19.19959, bear: 6.80041): 0.84600, ((sea lion:
%^^A11.99700, seal: 12.00300): 7.52973,((monkey: 100.85930, cat:47.14069): 20.59201,
%^^Aweasel: 18.87953): 2.09460): 3.87382, dog:25.46154);}
%
%^^A\phylogenetictree{(Bovine: 0.69395, (Gibbon: 0.36079, (Orang: 0.33636,
%^^A(Gorilla: 0.17147, (Chimp: 0.19268, Human: 0.11927): 0.08386): 0.06124):
%^^A0.15057): 0.54939, Mouse: 1.21460): 0.10;}
%
%^^A\phylogenetictree{(Bovine: 0.69395, (Hylobates: 0.36079,(Pongo: 0.33636,
%^^A(G._Gorilla: 0.17147, (P._paniscus: 0.19268, H._sapiens: 0.11927): 0.08386):
%^^A0.06124): 0.15057): 0.54939, Rodent: 1.21460);}
%
%^^A\phylogenetictree[distance=true,base width=0.05,base
%^^Aheight=.5]{(('raccoon':19.19959,bear:6.80041):0.84600,((sea_lion:11.99700,
%^^Aseal:12.00300):7.52973,((monkey:100.85930,cat:47.14069):20.59201,
%^^Aweasel:18.87953):2.09460):3.87382,dog:25.46154);}
%
%^^A\phylogenetictree[]{example1.tree}
%
% \end{documentation}
%
%\begin{implementation}
%
%\section{Implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%    
%    \begin{macrocode}
%<@@=phylogenetictree>
%    \end{macrocode}
%
%\subsection{The \LaTeX\ code}
%
%\subsubsection{Definitions and packages loading}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{xparse}
\ProvidesExplPackage 
  {phylogenetictree} 
  {2013/10/29} 
  {0.5}
  {Draw phylogenetic trees}
%    \end{macrocode}
%\macro{ifluatex}
%Ifluatex switch loading.
%    \begin{macrocode}
%\RequirePackage{ifluatex}
%    \end{macrocode}
%\macro{tikz} If the format is not \LaTeX, generate an error otherwise TikZ is
%loaded and comes with pgfkeys.
%    \begin{macrocode}
%\ifluatex
%  \RequirePackage{tikz}
%\else
%  \PackageError{phylogenetictree}%
%  {phylogenetictree only works with LuaTeX (LaTeX format)}%
%  {Switch your engine to luatex}
%\fi
%    \end{macrocode}
%\subsubsection{Key/value definitions}
%
%Start of \LaTeX3 syntax
%    \begin{macrocode}
\ExplSyntaxOn
\luatex_if_engine:TF
{\RequirePackage{tikz}}
{\PackageError{phylogenetictree}
{phylogenetictree only works with LuaTeX (LaTeX format)}
{Switch your engine to luatex}}
%    \end{macrocode}
%Here, we store in a property list all the keys with their respective default
%values. This is the only place where we keep key's name.
%    \begin{macrocode}
\prop_new:N   \g_@@_defaults_prop 
\prop_put:Nnn \g_@@_defaults_prop { draw_type }   { standalone }
\prop_put:Nnn \g_@@_defaults_prop { tree_type }   { straight }
\prop_put:Nnn \g_@@_defaults_prop { base_width }  { 1 }
\prop_put:Nnn \g_@@_defaults_prop { base_height } { 1 }
\prop_put:Nnn \g_@@_defaults_prop { angle }       { 90 }
\prop_put:Nnn \g_@@_defaults_prop { distance }    { false }
%    \end{macrocode}
%Each key/(default)value pair (stored in the property list !) is associated with
%a token list.
%    \begin{macrocode}
\prop_map_inline:Nn \g_@@_defaults_prop
{
  \keys_define:nn { phylogenetictree }
  {
    #1 .tl_set:c = { l_@@_#1_tl }
  }
}
%    \end{macrocode}
%\subsubsection{Internal functions}
%
%
%\begin{function}{ \@@_get_parameters:n }
%\begin{syntax}
%"\@@_get_parameters:n" \Arg{meta} <test_1>
%\end{syntax}
%<description>
%\end{function}
%    \begin{macrocode}
\cs_new:Npn \@@_get_parameters:n #1 
{
  \prop_clear_new:N \g_@@_prop
  \keys_set:nn { phylogenetictree } { #1 }
  \prop_map_inline:Nn \g_@@_defaults_prop
  {
    \tl_clear_new:N \l_@@_tmpa_tl
    \tl_set_eq:Nc 
      \l_@@_tmpa_tl 
      { l_@@_##1_tl }
    \tl_if_blank:VTF
      \l_@@_tmpa_tl
      { \prop_gput:Nnn \g_@@_prop { ##1 } { ##2 } }
      { \prop_gput:NnV \g_@@_prop { ##1 } \l_@@_tmpa_tl }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new:Npn \@@_get_value:n #1 
{
  \prop_get:Nn \g_@@_prop { #1 }
}
%    \end{macrocode}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_pass_to_lua:n #1 
{
  \lua_now_x:n 
  {
    arguments = 
    {
      drawtype = "\@@_get_value:n { draw_type }",
      treetype = "\@@_get_value:n { tree_type }",
      dx       = \@@_get_value:n { base_width },
      dy       = \@@_get_value:n { base_height },
      angle    = \@@_get_value:n { angle },
      distance = \@@_get_value:n { distance },
      tree     = "#1"
    }
    dofile("phylogenetictree.lua")
  }
}
%    \end{macrocode}
%If the argument is a filename, then open the file, read it and put the tree in
%a token list. Else put the tree in a token list.
%    \begin{macrocode}
\cs_new:Npn \@@_get_tree:n #1
{
  \file_if_exist:nTF
  { #1 }
  {
    \ior_new:N \l_@@_tree_file_ior
    \ior_open:Nn \l_@@_tree_file_ior { #1 }
    \ior_get:NN \l_@@_tree_file_ior \g_@@_newick_tree_tl
    \ior_close:N \l_@@_tree_file_ior
  }
  { \tl_gset:Nn \g_@@_newick_tree_tl { #1 } }
}
%    \end{macrocode}
%\subsubsection{User level function}
%\begin{macro}{\phylogenetictree}
%Key/val options are given between brackets (first argument). The tree is the
%second argument.
%    \begin{macrocode}
\NewDocumentCommand{\phylogenetictree}{ d[] m }
{
  \tl_gclear_new:N \g_@@_newick_tree_tl
  \@@_get_tree:n { #2 }
  \@@_get_parameters:n { #1 }
  \@@_pass_to_lua:n { #2 }
}
\ExplSyntaxOff
%    \end{macrocode}
%\end{macro}
%\iffalse
%</package>
%<*lua>
%\fi
%
%\subsection{The Lua Code}
%
%\macro{lpeg}
%The \verb|lpeg| module is required because Newick parser is written using it.
%    \begin{macrocode}
-- lpeg module
require "lpeg"
%    \end{macrocode}
%
%\subsubsection{Auxiliary functions}
%
%    \begin{macrocode}
--------------------------------------------------------------------------------
--                            Auxiliary functions                             --
--------------------------------------------------------------------------------
%    \end{macrocode}
%
%\begin{macro}{FindAllLeaves}
%La fonction \verb|FindAllLeaves| trouve puis copie toutes les feuilles
%associées à un nœud parent particulier. C'est une fonction récursive. Elle prend
%trois arguments : \verb|tree|, la table contenant le code de l'arbre parsé ;
%\verb|leaves|, une table dans laquelle sera écrit l'ensemble des feuilles ;
%\verb|parent|, un nœud parent.
%    \begin{macrocode}
-- FindAllLeaves function (recursive)
-- Finds all leaves of a tree associated with a particular node
function FindAllLeaves (tree, leaves, parent)
  if type(tree[parent]["childs"]) == "table" then
    for _,v in pairs (tree[parent]["childs"]) do
      FindAllLeaves (tree, leaves, v)
    end
  elseif tree[parent]["childs"] == nil then
    table.insert(leaves,parent)
  end
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{GetNum}
%The \verb|Getnum| function gives the total number of entries in an indexed
%table.
%    \begin{macrocode}
-- GetNum function
-- Give the total number of entries in an indexed table
function GetNum (table)
  local count = 0
  for k in pairs(table) do
    count = count + 1
  end
  return count
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{Gsub}
%The \verb|Gsub| function
%(\href{http://www.inf.puc-rio.br/~roberto/lpeg/\#ex}{lpeg documentation}) is an
%implementation of the \verb|string.gsub| function (plain lua) with \verb|lpeg|.
%    \begin{macrocode}
-- Gsub function
-- Implementation of the string.gsub function (plain lua) with lpeg
function Gsub (string, pattern, replacement)
  pattern = lpeg.P(pattern)
  pattern = lpeg.Cs((pattern / replacement + 1)^0)
  return lpeg.match(pattern, string)
end
%    \end{macrocode}
%\end{macro}
%\subsubsection{Newick Parser}
%
%    \begin{macrocode}
--------------------------------------------------------------------------------
--                                Newick Parser                               --
--------------------------------------------------------------------------------
%    \end{macrocode}
%
%\begin{macro}{NewickParser}
%The \verb|NewickParser| function transforms
%inline Newick notation into a table.
%    \begin{macrocode}
-- NewickParser function
-- Transforms inline Newick notation into a table
function NewickParser (newicktree)
%    \end{macrocode}
%\paragraph{Variables declarations}
%    \begin{macrocode}
  -- variable declarations
  local node         = {}
  local newicktable  = {}
  local node_number  = 1
  local current_node = 1
  local parent_node  = 0
  local counter      = 1
%    \end{macrocode}
% Pattern definitions: declaration of all the symbols used by Newick format.
%    \begin{macrocode}
  -- Newick grammar
  local space              = lpeg.P(" ")
  local digit              = lpeg.P(lpeg.R("09"))
  local number             = lpeg.P(digit + ".")
  local colon              = lpeg.P(":")
  local semicolon          = lpeg.P(";")
  local comma              = lpeg.P(",")
  local singlequote        = lpeg.P("'")
  local doublequote        = lpeg.P('"')
  local underscore         = lpeg.P("_")
  local leftparenthesis    = lpeg.P("(")
  local rightparenthesis   = lpeg.P(")")
  local leftsquarebracket  = lpeg.P("[")
  local rightsquarebracket = lpeg.P("]")
  local NewickPunctuation  = 
    lpeg.P(leftparenthesis + rightparenthesis + colon + semicolon + comma)	
  local comments           = lpeg.P(leftsquarebracket + rightsquarebracket)
%    \end{macrocode}
% Le motif suivant est plus complexe. Le code se base un des exemples donnés dans
% la \href{http://www.inf.puc-rio.br/~roberto/lpeg/\#ex}{documentation de |lpeg|
% (Balanced parentheses)}. Il s'agit de trouver une chaîne qui est
% \emph{exactement} entre deux crochets (\emph{balanced brackets}). Une chaîne
% entre crochets commence donc par
% \begin{enumerate}
% \item un crochet gauche,
% \item suivi de 0 ou plus répétitions de n'importe quoi sauf 1) des crochets
% (|(1 - lpeg.S("[]"))|) ou 2) une chaine entre crochets (|lpeg.V(1)|)
% \item et terminé par un crochet droit.
% \end{enumerate}
%    \begin{macrocode}
  local balancedcommentpattern = lpeg.P{
    leftsquarebracket * 
    ((1 - lpeg.S("[]")) + lpeg.V(1))^0
    * rightsquarebracket
  }
%    \end{macrocode}
%Le motif pour les guillemets simples est construit de la même
%façon que le motif précédent pour les crochets.
%    \begin{macrocode}
  local balancedsinglequotepattern = lpeg.P{
    singlequote * 
    ((1 - lpeg.S("'")) + lpeg.V(1))^0
    * singlequote
  }
%    \end{macrocode}
%Le motif pour les guillemets doubles est construit de la même
%façon que le motif précédent pour les crochets.
%    \begin{macrocode}
  local balanceddoublequotepattern = lpeg.P{
    doublequote * 
    ((1 - lpeg.S('"')) + lpeg.V(1))^0
    * doublequote
  }
%    \end{macrocode}
%\paragraph{Convert inline tree into a table}
%
%While the counter's value is smaller than the string's length, the loop
%continues.
%    \begin{macrocode}
  -- copy Newick's characters into the table
  while counter <= string.len(newicktree) do
%    \end{macrocode}
%If the character is one of the Newick's grammar, it is moved into the table and
%the counter is incremented by one.
%    \begin{macrocode}
    if lpeg.match(NewickPunctuation,newicktree,counter) then
      table.insert(
        newicktable,lpeg.match(
          lpeg.C(NewickPunctuation),newicktree,counter
        )
      )
      counter = counter + 1
%    \end{macrocode}
%If the character is a "[", it means there's a comment. It removes everything
%between "[" and "]" and the characters themselves.
%    \begin{macrocode}
    -- matches comments
    elseif lpeg.match(balancedcommentpattern,newicktree,counter) then
      counter = lpeg.match(balancedcommentpattern,newicktree,counter+1)
%    \end{macrocode}
%If the character is a \' or a \", it means there's a label. It matches everything
%between and.
%    \begin{macrocode}
    -- matches labels
    elseif lpeg.match(balancedsinglequotepattern,newicktree,counter) then
      table.insert(newicktable,lpeg.match(lpeg.C(balancedsinglequotepattern),
        newicktree,counter))
      counter = lpeg.match(balancedsinglequotepattern,newicktree,counter+1)

%    \end{macrocode}
%Remove spaces between Newick grammar.
%    \begin{macrocode}
    -- Remove spaces between Newick grammar
    elseif lpeg.match(space,newicktree,counter) then
      counter = counter + 1

%    \end{macrocode}
%Remove single quotes et replace underscore with space.
%    \begin{macrocode}
    -- Remove single quotes et replace underscore with space
    else
      local strpatt = lpeg.P((1-(NewickPunctuation + comments))^0)
      local str = lpeg.match(lpeg.C(strpatt),newicktree,counter)
      str = Gsub(str,singlequote,"")
      str = Gsub(str,underscore," ")
      table.insert(newicktable,str)
      strpatt = lpeg.P((1-NewickPunctuation)^0)
      counter = counter + (lpeg.match(strpatt,newicktree,counter)-counter)
    end
  end -- end of while loop

%    \end{macrocode}
%\paragraph{Construction of the final table}
%The node 1 (root) is its own parent.
%    \begin{macrocode}
  -- The node 1 (root) is its own parent
  node[1] = {
    type = "node",
    label = "",
    distance = 0,
    parent = 1,
    childs = {},
    x = 0,
    y = 0
  }

%    \end{macrocode}
%Loop each value in the temporary table.
%    \begin{macrocode}
  -- Loop each value in the temporary table
  for k,v in pairs(newicktable) do

%    \end{macrocode}
%Left parenthesis: create a new child node.
%    \begin{macrocode}
    -- Left parenthesis : create a new child node
    if lpeg.match(leftparenthesis,v) then
      parent_node = node_number
      node_number = node_number + 1
      current_node = node_number
      table.insert((node[parent_node]["childs"]), current_node)
      node[current_node] = {
        type = "node",
        label = "",
        distance = 1,
        parent = parent_node,
        childs = {},
        x = 0,
        y = 0
      }
      if lpeg.match(comma,newicktable[k+1]) then
        node[current_node]["type"] = "leaf"
      end

%    \end{macrocode}
%Comma: come back to parent and create new child node.
%    \begin{macrocode}
    -- Comma: come back to parent and create new child node
    elseif lpeg.match(comma,v) then
      parent_node = node[current_node]["parent"]
      node_number = node_number + 1
      current_node = node_number
      table.insert(node[parent_node]["childs"], current_node)
      node[current_node] = {
        type = "node",
        label = "",
        distance = 1,
        parent = parent_node,
        childs = {},
        x = 0,
        y = 0
      }
      if lpeg.match(rightparenthesis,newicktable[k+1]) then
        node[current_node]["type"] = "leaf"
      end

%    \end{macrocode}
%Right parenthesis: come back to parent node.
%    \begin{macrocode}
    -- Right parenthesis: come back to parent node
    elseif lpeg.match(rightparenthesis,v) then
      current_node = parent_node
      parent_node = node[parent_node]["parent"]

%    \end{macrocode}
%Semicolon: end of tree and so end of loop!
%    \begin{macrocode}
    elseif lpeg.match(semicolon,v) then
      break
%    \end{macrocode}
%Colon: do nothing in the loop (it means there's a distance, but it's not
%important for the moment)
%    \begin{macrocode}
    elseif lpeg.match(colon,v) then
%    \end{macrocode}
%A number is a distance. We put this number in the node table.
%    \begin{macrocode}
    elseif lpeg.match(number,v) then
      node[current_node]["distance"] = v
%    \end{macrocode}
%Internal node label. If the current value is not a Newick sign but the previous
%is a right parenthesis, then it's the name of an internal node.
%    \begin{macrocode}
    elseif lpeg.match(rightparenthesis,newicktable[k-1]) then
      node[current_node]["label"] = v
%    \end{macrocode}
%Anything else is the label of an external node (a leaf).
%    \begin{macrocode}
    else
      node[current_node]["type"] = "leaf"
      node[current_node]["label"] = v
      node[current_node]["childs"] = nil
    end

%    \end{macrocode}
%End of loop, end of function, return the node table.
%    \begin{macrocode}
  end
  return node -- return thee node table
end
%    \end{macrocode}
%\end{macro}
%\subsubsection{Composing functions}
%
%    \begin{macrocode}
--------------------------------------------------------------------------------
--                            Composing functions                             --
--------------------------------------------------------------------------------
%    \end{macrocode}
%
%\begin{macro}{Table2FoldTree}
%Compute node coordinates with fold angles
%    \begin{macrocode}
-- Table2FoldTree function
-- Compute node coordinates with fold angles
function Table2FoldTree (node)
  local parent = {}
  local currentparent = 0
  local child = {}
  local coordinates = {x={},y=1}
%    \end{macrocode}
%    \begin{macrocode}
  for k in ipairs(node) do
    if node[k]["type"] == "leaf" then
      table.insert(parent,node[k]["parent"])
      node[k]["y"] = coordinates["y"] - arguments["dy"]
      coordinates["y"] = node[k]["y"]
    end
  end
%    \end{macrocode}
%Loop while parent is superior to 1
%    \begin{macrocode}
  -- boucle tant que parent est supérieur à 1
  while GetNum(parent) > 1 do 
    -- on réinitialise les tables temporaires
    coordinates = {x={},y={}}
    child = {}
-- on prend le parent avec le numéro le plus élevé (pour avoir la racine en
-- dernier)
    currentparent =math.max(table.unpack(parent))
    -- on prend tous les enfants du parent courant --> child
    for k,v in pairs(node[currentparent]["childs"]) do
      table.insert(child,v)
    end
    -- on récupère les coordonnées des enfants
    for k,v in pairs(child) do
      table.insert(coordinates["x"],node[v]["x"])
      table.insert(coordinates["y"],node[v]["y"])
    end

		-- on calcule les coordonnées du parent
node[currentparent]["x"] = (math.min(table.unpack(coordinates["x"])))-arguments["dx"] node[currentparent]["y"] =
              (math.max(table.unpack(coordinates["y"])))
             -((math.abs((math.max(table.unpack(coordinates["y"])))
             -(math.min(table.unpack(coordinates["y"])))))/2)

		-- on enlève les noeuds avec le parent en cours
		local counter = 1
		while parent[counter] ~= nil do
			if parent[counter] == currentparent then
				table.remove(parent,counter)
			else
				counter = counter + 1
			end
		end
		
		-- on ajoute le parent du noeud parent
		table.insert(parent,node[currentparent]["parent"])
	end

	-- on positionne la noeud root à 0,0
	local xroot = node[1]["x"]
	local yroot = node[1]["y"]
	for k in pairs(node) do
		node[k]["x"] = node[k]["x"]-xroot
		node[k]["y"] = node[k]["y"]-yroot
	end
	return node
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{Table2FoldTreeDistance}
%    \begin{macrocode}
-- Table2FoldTreeDistance function
-- calcule les coordonnées des noeuds avec des 
-- branches à angle droit en respectant les distances
function Table2FoldTreeDistance (node)
  Table2FoldTree(node)
  for k in ipairs(node) do -- on décale les noeuds en x pour avoir les bonnes coordonnées
    node[k]["x"] = node[node[k]["parent"]]["x"] +
    arguments["dx"]*node[k]["distance"]
  end
  return node
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{Table2StraightTree}
%calcule les coordonées des noeuds avec des branches en ligne droite
%    \begin{macrocode}
-- calcule les coordonées des noeuds avec des branches en ligne droite
function Table2StraightTree (node)

  local parent = {}
  local currentparent = 0
  local child = {}
  local coordinates = {x={},y=1}

  -- place les feuilles de l'arbre
  for k in ipairs(node) do
    if node[k]["type"] == "leaf" then
      table.insert(parent,node[k]["parent"])
      node[k]["y"] = coordinates["y"] - arguments["dy"] -- on modifie y du noeud
      coordinates["y"] = node[k]["y"]
    end
  end

  -- boucle tant que parent est supérieur à 1
  while GetNum(parent) > 1 do

    -- on réinitialise les tables temporaires
    coordinates = {x={},y={}}
    child = {}

-- on prend le parent avec le numéro le plus élevé (pour avoir la racine en
-- dernier)
    currentparent = math.max(table.unpack(parent))

-- on cherche toutes les feuilles du parent recherché et on les ajoute dans
-- childs
    FindAllLeaves(node,child,currentparent)

    -- on prend tous les enfants directs du parent courant --> child
    for k,v in pairs(node[currentparent]["childs"]) do
      table.insert(child,v)
    end

    -- on récupère les coordonnées des enfants
    for k,v in pairs(child) do
      table.insert(coordinates["x"],node[v]["x"])
      table.insert(coordinates["y"],node[v]["y"])
    end

    local xmin = math.min(table.unpack(coordinates["x"]))
    local xmax = math.max(table.unpack(coordinates["x"]))
    local ymin = math.min(table.unpack(coordinates["y"]))
    local ymax = math.max(table.unpack(coordinates["y"]))
%    \end{macrocode}
%$dx$ computation
%\[|y_{max}-y_{min}\|\times 0.5\]
%    \begin{macrocode}
    local dx = (
      ((math.abs(ymax-ymin))*.5)
      *
      (math.sqrt((1+math.cos(math.rad(arguments["angle"])))
       /
       (1-math.cos(math.rad(arguments["angle"])))))
     )

    -- on calcule les coordonnées du parent
    node[currentparent]["x"] = xmax-dx
    node[currentparent]["y"] = ymax-((math.abs(ymax-ymin))/2)

    -- on enlève les noeuds avec le parent en cours
    local counter = 1
    while parent[counter] ~= nil do
      if parent[counter] == currentparent then
        table.remove(parent,counter)
      else
        counter = counter + 1
      end
    end
		
    -- on ajoute le parent du noeud parent
    table.insert(parent,node[currentparent]["parent"])
  end

  -- on positionne la noeud root à 0,0
  local xroot = node[1]["x"]
  local yroot = node[1]["y"]
  for k in pairs(node) do
    node[k]["x"] = node[k]["x"]-xroot
    node[k]["y"] = node[k]["y"]-yroot
  end
  return node
end

%    \end{macrocode}
%\end{macro}
%\subsubsection{Drawing functions}
%
%    \begin{macrocode}
--------------------------------------------------------------------------------
--                            Drawing functions                               --
--------------------------------------------------------------------------------
%    \end{macrocode}
%
%\begin{macro}{Labels}
%    \begin{macrocode}
-- print labels
function Labels (node)
  for k in ipairs (node) do
    tex.print([[\node [anchor=west] at (]]
    ..node[k]["x"]..[[cm,]]
    ..node[k]["y"]..[[cm) (]]..k..[[) {]]
    ..node[k]["label"]..[[};]])
  end
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{NodeNumber}
%print node numbers (debug)
%    \begin{macrocode}
-- print node numbers (debug)
function NodeNumber (node)
  for k in ipairs (node) do
    tex.print([[\node [draw,anchor=south east,circle] at (]]
    ..node[k]["x"]..[[cm,]]
    ..node[k]["y"]..[[cm) (]]..k..[[) {\scriptsize{]]..k..[[}};]])
  end
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{FoldTree}
%Relie tous les noeuds en formant un angle droit
%    \begin{macrocode}
-- Relie tous les noeuds en formant un angle droit
function FoldTree (node)
  for k in ipairs (node) do
    tex.print([[\draw(]]
    ..node[node[k]["parent"]]["x"]..[[cm,]]
    ..node[node[k]["parent"]]["y"]..[[cm) |- (]]
    ..node[k]["x"]..[[cm,]]
    ..node[k]["y"]..[[cm);]])
  end
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{StraightTree}
%    \begin{macrocode}
function StraightTree (node)
  for k in ipairs (node) do
    tex.print([[\draw(]]
    ..node[node[k]["parent"]]["x"]..[[cm,]]
    ..node[node[k]["parent"]]["y"]..[[cm) -- (]]
    ..node[k]["x"]..[[cm,]]
    ..node[k]["y"]..[[cm);]])
  end
end
%    \end{macrocode}
%\end{macro}
%\begin{macro}{TikzDraw}
%    \begin{macrocode}
-- encapsule le code dans un tikzpicture
function TikzDraw (tree)

  local starttikzenv
  local endtikzenv
	
  -- plain or latex
  if arguments["drawtype"] == "standalone" then
    starttikzenv = [[\begin{tikzpicture}]]
    endtikzenv = [[\end{tikzpicture}]]
  elseif arguments["drawtype"] == "scope" then
    starttikzenv = [[\begin{scope}]]
    endtikzenv = [[\end{scope}]]
  end

  tex.print(starttikzenv)
  if arguments["treetype"] == "straight" then
    if arguments["distance"] == false then
      StraightTree(Table2StraightTree(tree))
      Labels(tree)
    elseif arguments["distance"] == true then
      StraightTree(Table2StraightTreeDistance(tree))
      Labels(tree)
    end
  elseif arguments["treetype"] == "fold" then
    if arguments["distance"] == false then
      FoldTree(Table2FoldTree(tree))
      Labels(tree)
    elseif arguments["distance"] == true then
      FoldTree(Table2FoldTreeDistance(tree))
      Labels(tree)
    end
  end
  tex.print(endtikzenv)
end
%    \end{macrocode}
%\end{macro}
%
%    \begin{macrocode}
TikzDraw(NewickParser(arguments["tree"]))
%    \end{macrocode}
%\iffalse
%</lua>
%\fi
%
% \end{implementation}
%
% \PrintChanges
%
% \PrintIndex